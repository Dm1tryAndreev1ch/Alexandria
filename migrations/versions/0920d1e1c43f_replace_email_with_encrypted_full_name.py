"""Replace email with encrypted full_name

Revision ID: 0920d1e1c43f
Revises: 2fba4d5bd965
Create Date: 2025-11-23 18:40:23.840555

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0920d1e1c43f'
down_revision = '2fba4d5bd965'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    connection = op.get_bind()
    
    # Проверяем, существует ли колонка full_name_encrypted
    inspector = sa.inspect(connection)
    columns = [col['name'] for col in inspector.get_columns('users')]
    
    # Сначала добавляем колонку как nullable (если её нет)
    if 'full_name_encrypted' not in columns:
        op.add_column('users', sa.Column('full_name_encrypted', sa.Text(), nullable=True))
    
    # Заполняем существующие записи (используем username как временное значение)
    import hashlib
    import base64
    
    # Получаем SECRET_KEY для шифрования
    import os
    from dotenv import load_dotenv
    load_dotenv()
    secret_key = os.getenv('SECRET_KEY', 'default-secret-key-change-me')
    key_bytes = hashlib.sha256(secret_key.encode('utf-8')).digest()
    key = base64.urlsafe_b64encode(key_bytes)
    
    from cryptography.fernet import Fernet
    fernet = Fernet(key)
    
    # Обновляем существующие записи, у которых нет full_name_encrypted
    result = connection.execute(sa.text("SELECT id, username FROM users WHERE full_name_encrypted IS NULL"))
    for row in result:
        user_id, username = row
        # Шифруем username как временное ФИО
        encrypted = fernet.encrypt(username.encode('utf-8')).decode('utf-8')
        connection.execute(
            sa.text("UPDATE users SET full_name_encrypted = :encrypted WHERE id = :id"),
            {"encrypted": encrypted, "id": user_id}
        )
    connection.commit()
    
    # SQLite не поддерживает ALTER COLUMN, поэтому колонка создается как NOT NULL
    # Если колонка уже существует и nullable, нужно пересоздать таблицу
    # Для простоты, если колонка уже есть и nullable, пропускаем изменение
    
    # Удаляем колонку email (если она существует)
    # SQLite может иметь проблемы с DROP COLUMN, используем try-except
    try:
        columns_after = [col['name'] for col in inspector.get_columns('users')]
        if 'email' in columns_after:
            op.drop_column('users', 'email')
    except Exception as e:
        # Если колонка уже удалена или возникла ошибка, пропускаем
        print(f"Note: Could not drop email column: {e}")
        pass

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('users', schema=None) as batch_op:
        batch_op.add_column(sa.Column('email', sa.VARCHAR(length=120), nullable=False))
        batch_op.drop_column('full_name_encrypted')

    # ### end Alembic commands ###
